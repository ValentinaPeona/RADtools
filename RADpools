#!/usr/bin/env perl

# RADpools

# History:
# 16/05/10 First public version
# 02/07/10 Changed defaults to avoid trimming reads
# 18/07/10 Added MID length parameter and changed default to reject zombies,
#          not accept them
# 03/08/10 Incorporated into RADtools
# 05/08/10 Run through perlcritic, tidied up options, added POD,
#          removed benchmarking, added main() for testing purposes
# 20/08/10 Added sorting the read pools using Parallel::ForkManager
# 25/08/10 Catch absence of Parallel::ForkManager

#############################################################################
###
### PREAMBLE
###
#############################################################################

# Core pragmas and modules
use strict;
use warnings;
use English qw( -no_match_vars );
use Getopt::Long qw( :config bundling no_auto_abbrev auto_version );
use Pod::Usage;
use File::Copy;

# Non-core modules
eval {
require Parallel::ForkManager;
Parallel::ForkManager->import();
};
die "RADpools requires the CPAN module Parallel::ForkManager. Please install this package and add it to your Perl library path.\n" if $@;

# Would like to use Carp, but an outstanding bug causes cryptic errors
# when using caller(), so using die until this is fixed
# http://www.nntp.perl.org/group/perl.perl5.porters/2010/03/msg157461.html

local $main::VERSION    = 0.1;    # Used by Getopt::Long to provide --version
local $OUTPUT_AUTOFLUSH = 1;      # So reporting on progress works

main(@ARGV) unless caller;        # So test suite can call script

sub main {

    # Set up default options

    my $help  = 0;
    my $usage = 0;
    my $man   = 0;

    my $verbose = 0;

    my $read1_file = q{};
    my $read2_file = q{};
    my $species    = q{};
    
    my $max_processes = 1;

    my $res_site                = 'TGCAGG';    #SbfI
    my $mid_length              = 5;
    my $minimum_sequence_length = 0;
    my $quality_threshold       = -5;
    my $trim                    = 0;
    my $zombies_accepted        = 0;

    # Load user options
    my $options_okay = GetOptions(

        'help|h'    => \$help,
        'usage'     => \$usage,
        'man'       => \$man,
        'verbose|v' => \$verbose,

        'in|i=s'      => \$read1_file,
        'paired|p=s'  => \$read2_file,
        'species|s=s' => \$species,
        
        'max_processes|m=i' => \$max_processes,

        'enzyme|e=s'            => \$res_site,
        'mid-length|mid=i'      => \$mid_length,
        'min-read-length|min=i' => \$minimum_sequence_length,
        'quality|q=i'           => \$quality_threshold,
        'trim|t'                => \$trim,
        'zombies-accepted|z'    => \$zombies_accepted,

    ) or pod2usage( -verbose => 0 );

    pod2usage( -verbose => 0 ) if $usage;
    pod2usage( -verbose => 1 ) if $help;
    pod2usage( -verbose => 2 ) if $man;

    # Validate options
    pod2usage( -verbose => 0 ) if ( $read1_file eq q{} );
    pod2usage( -verbose => 0 ) if ( $species    eq q{} );

#############################################################################
###
### LOAD POOLS AND MIDS
###
#############################################################################

    my $res_site_length = length $res_site;

    my %mid_pools    = ();
    my %pool_handles = ();
    if ($verbose) { print "Loading pools and MIDs...\n"; }

    if ( $species ne q{} ) {

        # Load pools from file into an array
        my $pool_file = $species . '.pools';
        open my $poolhandle, '<', $pool_file
          or die "Couldn't open '$pool_file': $OS_ERROR\n";
        my @pools = <$poolhandle>;
        close $poolhandle or die "Can't close $pool_file: $OS_ERROR\n";

        if ( !-d "./$species" ) {
            mkdir "./$species"
              or die
              "Can't create directory for $species output files: $OS_ERROR!\n";
        }

        # Load MIDs for all pools
        foreach my $pool_line (@pools) {
            chomp $pool_line;

            my @pool_mid_list = split / /, $pool_line;

            my $pool_name = shift @pool_mid_list;

            # Load MIDs into array and set up hash of MIDs for pool lookup

            foreach my $mid (@pool_mid_list) {
                if ( !$zombies_accepted ) {
                    push @{ $mid_pools{$mid} }, $pool_name;
                }
                else {
                    for my $i ( 1 .. $mid_length ) {
                        for my $base (qw{A C G T}) {
                            my $fuzzycode  = $mid;
                            my $prebase_i  = $i - 1;
                            my $postbase_i = $mid_length - $i;
                            $fuzzycode =~ s{^([ACGT]{$prebase_i})
                            ([ACGT])
                            ([ACGT]{$postbase_i})$}
                            {$1$base$3}xms;
                            push @{ $mid_pools{$fuzzycode} }, $pool_name;
                        }
                    }
                }
            }
        }
    }
    else {
        die 'Please name a species for pools and MIDs using the -s option';
    }

    # Collapse lists of pools for each MID into unique, sorted, string
    foreach my $mid ( keys %mid_pools ) {
        my @pool_list = sort @{ $mid_pools{$mid} };
        my $seen      = q{};

        # Get unique elements of list
        @pool_list = grep { ( $_ ne $seen ) && ( ($seen) = $_ ) } @pool_list;

        if ( ( !$zombies_accepted ) && ( @pool_list > 1 ) ) {
            delete $mid_pools{$mid};
        }
        else {

            my $pool_string = q{};

            # Collapse list of pools
            foreach my $pool (@pool_list) {
                $pool_string = $pool_string . $pool . '.';
            }

            # Get rid of trailing /
            chop $pool_string;
            $mid_pools{$mid} = $pool_string;

            open $pool_handles{$pool_string}, '>',
              "./$species/$species\_$pool_string\.reads"
              or die "Can't open output file for $pool_string: $OS_ERROR\n";
        }
    }

    # Make fuzzy list of restriction enzyme sites

    my %fuzzy_res_sites = ();
    for my $i ( 1 .. $res_site_length ) {
        for my $base (qw{A C G T}) {
            my $fuzzyseq   = $res_site;
            my $prebase_i  = $i - 1;
            my $postbase_i = $res_site_length - $i;
            $fuzzyseq =~ s{^([ACGT]{$prebase_i})
               ([ACGT])
               ([ACGT]{$postbase_i})$}
               {$1$base$3}xms;
            $fuzzy_res_sites{$fuzzyseq} = $res_site;
        }
    }

#############################################################################
###
### LOAD FASTQ RECORDS
###
#############################################################################

    if ($verbose) { print "Loading RAD reads...\n"; }

    # Initialise sequence, quality and RAD variables

    my $fastq_sequence_header = q{};    # Empty string
    my $fastq_sequence        = q{};
    my $fastq_quality_header  = q{};
    my $fastq_quality         = q{};

    my $quality_tail       = q{};
    my $sequence           = q{};
    my $record_count_total = 0;
    my $record_count_valid = 0;

    # Open RAD sequence file
    open my $read1_in, '<', $read1_file
      or die "Couldn't open '$read1_file': $OS_ERROR";

    my $read2_in;
    if ( $read2_file ne q{} ) {
        open $read2_in, '<', $read2_file
          or die "Couldn't open '$read2_file': $OS_ERROR";
    }

    # Create a directory for the species if it doesn't already exist
    if ( !( -d "./$species" ) ) {
        mkdir "./$species" or die "Can't make ./$species: $OS_ERROR";
    }

    # Output invalid/unclustered sequences
    my $results_file_stem = "./$species/$species\_" . get_timestamp();
    my $invalid_file      = "$results_file_stem\_invalid.txt";
    open my $invalid_handle, '>', $invalid_file
      or die "Can't open $invalid_file: $OS_ERROR";

    print {$invalid_handle}
"Input files: $read1_file, $read2_file; Species: $species, Enzyme site: $res_site; Minimum length: $minimum_sequence_length; Quality threshold: $quality_threshold\n"
      or die "Can't write to $invalid_file: $OS_ERROR\n";

    # Load RAD sequences into hash of pools with counts for identical sequences

    my $non_fastq_count        = 0;
    my $wrong_rad_format_count = 0;
    my $wrong_ressite_count    = 0;
    my $wrong_mid_count        = 0;
    my $short_sequence_count   = 0;

  LOAD_ONE_SEQUENCE:
    while ( $fastq_sequence_header = <$read1_in> ) {

        $fastq_sequence       = q{};    # Empty string
        $fastq_quality_header = q{};
        $fastq_quality        = q{};

        my $read2_header         = q{};
        my $read2_sequence       = q{};
        my $read2_quality_header = q{};
        my $read2_quality        = q{};

        # Find start of a FASTQ record (line beginning with @)
        if ( $fastq_sequence_header =~ /^@(\S+)/xms ) {
            $fastq_sequence       = <$read1_in>;
            $fastq_quality_header = <$read1_in>;
            $fastq_quality        = <$read1_in>;
            chomp $fastq_sequence;
            chomp $fastq_quality;
            if ( $read2_file ne q{} ) {
                $read2_header         = <$read2_in>;
                $read2_sequence       = <$read2_in>;
                $read2_quality_header = <$read2_in>;
                $read2_quality        = <$read2_in>;

                chomp $read2_sequence;
                chomp $read2_quality;
            }
        }

        # Throw away bad FASTQ records
        if (   ( $fastq_sequence !~ /^[AGCTN\.]+$/xms )
            || ( $fastq_quality_header !~ /^\+/xms )
            || ( $fastq_quality !~ /^[;-h]+$/xms ) )
        {
            chomp $fastq_sequence_header;
            chomp $fastq_quality_header;

            print {$invalid_handle}
"Sequence, quality or quality header not valid FASTQ: $fastq_sequence $fastq_quality $fastq_sequence_header $fastq_quality_header\n"
              or die "Can't write to $invalid_file: $OS_ERROR\n";
            $non_fastq_count++;
            next LOAD_ONE_SEQUENCE;
        }

        # Update progress meter
        $record_count_total++;
        if ( ($verbose) && ( $record_count_total % 100_000 == 0 ) ) {
            printf "OK: %8d | FASTQ: %8d | RAD: %8d | Res: %8d | MID: %8d | Short: %8d\n", $record_count_valid, $non_fastq_count, $wrong_rad_format_count, $wrong_ressite_count, $wrong_mid_count, $short_sequence_count;
        }

        # Find any point where Q<20 and strip off sequence following this point
        # Q=20 is ASCII M; Q=40 is ASCII h
        # This automatically strips the N / ; off the end of the sequence
        my $qual_threshold_char = chr( $quality_threshold + 64 );
        if ( $fastq_quality =~ m{(\A[$qual_threshold_char-h]+)}xms ) {
            $quality_tail = $1;
        }
        else {
            $quality_tail = q{};
        }

        # Get substring of sequence of length quality_substring
        $sequence = substr( $fastq_sequence, 0, length $quality_tail );

        my $mid          = q{};    # Empty string
        my $seq_res_site = q{};
        my $dna_sequence = q{};

        # Find restriction enzyme site; if not found, skip sequence
        if (
            $sequence =~ m{^([AGCTN]{$mid_length})
                        ([AGCTN]{$res_site_length})
                        ([AGCTN\.]+)$}xms
          )
        {
            ( $mid, $seq_res_site, $dna_sequence ) = ( $1, $2, $3 );
        }
        else {
            chomp $fastq_sequence_header;
            chomp $fastq_sequence;
            chomp $fastq_quality_header;
            chomp $fastq_quality;

            print {$invalid_handle}
"Sequence is not a valid RAD sequence               : $fastq_sequence $fastq_quality $sequence\n"
              or die "Can't write to $invalid_file: $OS_ERROR\n";
            $wrong_rad_format_count++;
            next LOAD_ONE_SEQUENCE;
        }

        if ( !( exists $fuzzy_res_sites{$seq_res_site} ) ) {

            print {$invalid_handle} 'Restriction enzyme site does not match'
              . "             : $fastq_sequence $fastq_quality "
              . "$seq_res_site $sequence\n"
              or die "Can't write to $invalid_file: $OS_ERROR\n";
            $wrong_ressite_count++;
            next LOAD_ONE_SEQUENCE;
        }

        # Find pool for this MID; if no pool, make pool for this MID alone
        if ( !( exists $mid_pools{$mid} ) ) {

            # Check one-base-pair variants of MID in case of sequencing error

            # If MID not found, reject read
            print {$invalid_handle} 'MID is not a valid MID'
              . "                     : $fastq_sequence $fastq_quality "
              . "$mid $sequence\n"
              or die "Can't write to $invalid_file: $OS_ERROR\n";
            $wrong_mid_count++;
            next LOAD_ONE_SEQUENCE;
        }
        my $pool = $mid_pools{$mid};

        # Increment the number of times this sequence has occurred
        if ( length($dna_sequence) >= $minimum_sequence_length ) {

            # Remove MID and res site bases from read 1 quality string
            if ( $quality_tail =~
                m{^(.{$mid_length})(.{$res_site_length})(.+)$}xms )
            {
                $quality_tail = $3;
            }
            if ($trim) {
                $dna_sequence = substr $dna_sequence, 0,
                  $minimum_sequence_length;
                $quality_tail = substr $quality_tail, 0,
                  $minimum_sequence_length;
            }
            print { $pool_handles{$pool} } "$dna_sequence $quality_tail"
              or die "Can't write to pools file: $OS_ERROR\n";
            if ( $read2_file ne q{} ) {
                print { $pool_handles{$pool} }
                  " $read2_sequence $read2_quality";
            }
            print { $pool_handles{$pool} } "\n";
            $record_count_valid++;
        }

        # Otherwise, sequence is too short; throw it away
        else {
            print {$invalid_handle} 'Sequence shorter than '
              . $minimum_sequence_length
              . ' base pairs                : '
              . "$fastq_sequence $fastq_quality $dna_sequence\n"
              or die "Can't write to $invalid_file: $OS_ERROR\n";
            $short_sequence_count++;

        }

    }
    close $read1_in or die "Can't close $read1_file: $OS_ERROR\n";

    if ( $read2_file ne q{} ) {
        close $read2_in or die "Can't close $read2_file: $OS_ERROR\n";
    }

    foreach my $pool ( keys %pool_handles ) {
        close $pool_handles{$pool} or die "Can't close pool files: $OS_ERROR\n";
    }

#    my @pids; # Array of pid's children, so can test each child for completion individually if wish.
#    my @pool_ids = sort keys %pool_handles;
#    for my $i (0..$#pool_ids) {
#        $pids[$i]=fork();
#        if (not defined $pids[$i]) {print "\nCan't create child process $i\n";}
#        elsif ($pids[$i] == 0) {
#            my $read_file = "./$species/$species\_$pool_ids[$i]\.reads";
#            print "$read_file\n";
#            system("sort -T ./$species --output=$read_file\.sort $read_file" );
#            move("$read_file\.sort",$read_file);
#            exit 0;
#        }
#        else { # parent process, do nothing
#        }
#    }

    #    foreach my $pid (@pids) {
    #        waitpid($pid,0);
    #    }

    if ($verbose) {print "Sorting pooled reads...\n";}

    my @pool_ids = sort keys %pool_handles;
    my $pm       = new Parallel::ForkManager(@pool_ids);
    $pm->set_max_procs($max_processes);

    foreach my $pool_id (@pool_ids) {
        $pm->start and next;

        my $read_file = "./$species/$species\_$pool_id\.reads";
        print "Sorting $read_file...\n";
        system("sort -T ./$species --output=$read_file\.sort $read_file");
        move( "$read_file\.sort", $read_file );

        $pm->finish;
    }

    $pm->wait_all_children;


    print {$invalid_handle}
      "$record_count_valid records loaded, but discarded \n"
      . "$non_fastq_count records not in FASTQ format, \n"
      . "$wrong_rad_format_count records not in RAD format, \n"
      . "$wrong_ressite_count records not matching restriction enzyme site, \n"
      . "$wrong_mid_count records not matching any listed MIDs, and \n"
      . "$short_sequence_count records with high-quality sequences less than $minimum_sequence_length long\n"
      or die "Can't write to $invalid_file: $OS_ERROR\n";

    close $invalid_handle or die "Can't close $invalid_file: $OS_ERROR\n";

    # Output records loaded and discarded
    if ($verbose) {

        print "$record_count_valid records loaded, but discarded \n"
          . "$non_fastq_count records not in FASTQ format, \n"
          . "$wrong_rad_format_count records not in RAD format, \n"
          . "$wrong_ressite_count records not matching restriction enzyme site, \n"
          . "$wrong_mid_count records not matching any listed MIDs, and \n"
          . "$short_sequence_count records with high-quality sequences less than $minimum_sequence_length long\n"
          . "Done\n";
    }


    return;
}

#############################################################################
###
### SUBROUTINES
###
#############################################################################


#############################################################################
### Name:       GET TIMESTAMP
### Function:   gets and formats the current time
### Parameters: None
### Returns:    Current time as YYYYMMDD_HHMMSS
#############################################################################

sub get_timestamp {
    my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime time;
    $mon++;
    $year += 1900;
    if ( $mon < 10 )  { $mon  = "0$mon"; }
    if ( $mday < 10 ) { $mday = "0$mday"; }
    if ( $hour < 10 ) { $hour = "0$hour"; }
    if ( $min < 10 )  { $min  = "0$min"; }
    if ( $sec < 10 )  { $sec  = "0$sec"; }

    return $year . $mon . $mday . '_' . $hour . $min . $sec;
}

__END__

#############################################################################
###
### DOCUMENTATION
###
#############################################################################

=head1 NAME

RADpools - Take raw Illumina RAD reads and create read files for a set of pools

=head1 VERSION

This documentation refers to RADtools version 0.1.

=head1 SYNOPSIS

=over 8

=item RADpools --in file --species species_name [options]

=item RADpools --help

=back

=head1 OPTIONS

=over 8

=item B<-h, --help>

Print a brief help message and exit

=item B<--usage>

Print concise usage and exit

=item B<--man>

Print the manual page and exit

=item B<--version>

Print version number and exit

=item B<-v, --verbose>

Output status messages during run (default off)

=item B<-i, --in>

File containing single end Illumina RAD reads in FASTQ format (required)

=item B<-p, --paired>

File containing paired end Illumina RAD reads in FASTQ format (optional)

=item B<-s, --species>

Name of species to be sequenced, matching name of pools file (required)

=item B<-m, --max_processes>

Maximum number of processes to use for sorting read pools after input files have been processed. Default 1; increasing --max_processes is highly recommended if more cores are available.

=item B<-e, --enzyme>

Sequence of cut site for used restriction enzyme (default TGCAGG, SbfI)

=item B<-mid, --mid-length>

Length of MID sequences (default 5)

=item B<-min, --min-read-length>

Minimum acceptable length of high quality reads (default 0, ie all reads accepted)

=item B<-q, --quality>

Minimum acceptable quality score (default -5, ie all bases accepted)

=item B<-t, --trim>

Trim all reads to minimum sequence length (set by B<--min-read-length>)

=item B<-z, --zombies-accepted>

If a read cannot be unambiguously assigned to a MID, create a new MID for the intermediate sequence (default off)

=back

=head1 DESCRIPTION

B<RADpools> accepts as input one or two FASTQ files containing single or
paired end GERALD output from an Illumina RAD sequencing run. These RAD
sequences contain MIDs which identify the individuals from which the
sequence came. This script loads in the pools to which the MIDs belong and
assigns the sequences to the appropriate pools. It then writes out the
sequences to separate files, one for each pool.

=head1 AUTHOR

John Davey <john.davey@ed.ac.uk>

=head1 LICENCE AND COPYRIGHT

Copyright 2008, 2010 John Davey, University of Edinburgh <john.davey@ed.ac.uk>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
